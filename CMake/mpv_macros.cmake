#
# This macro (intended to be invoked in the first line
# of an mpv plugins' CMakeLists.txt) allows adding common
# include paths without necessarily adding these paths
# globally for all compiled code.
#
# Most plugins should call this macro with no arguments
# other than their target name.  In the event a plugin
# does NOT need the CIGI Class Library or MPV common
# library it can declare NOCCL and NOCOMMON as additional 
# arguments.
#
# Example:
# MPV_PLUGIN_INIT(pluginRenderFooOSG)
# MPV_PLUGIN_INIT(pluginStandalone NOCCL NOCOMMON)
#
MACRO(MPV_PLUGIN_INIT _target)
    IF(NOT "${ARGN}" MATCHES "NOCCL")
        INCLUDE_DIRECTORIES(${CCL_INCLUDE_DIRS})
    ENDIF(NOT "${ARGN}" MATCHES "NOCCL")
    
    IF(NOT "${ARGN}" MATCHES "NOCOMMON")
        INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/common)
    ENDIF(NOT "${ARGN}" MATCHES "NOCOMMON")
    
    IF(NOT "${ARGN}" MATCHES "NOPDL")
        INCLUDE_DIRECTORIES(${PDL_INCLUDE_DIRS})
    ENDIF(NOT "${ARGN}" MATCHES "NOPDL")
ENDMACRO(MPV_PLUGIN_INIT)

#
# This macro is intended to be invoked on all MPV plugins
# after the target has been declared.
#
MACRO(MPV_PLUGIN_PROCESS_TARGET target)
    IF(MSVC)
        # With MSVC on Win32 change the generated DLL to
        # have a lib in front of it.  This makes plugins.def
        # useable in Linux or Windows.
        SET_TARGET_PROPERTIES(${target} PROPERTIES
            OUTPUT_NAME lib${target} )
    ENDIF(MSVC)
    IF(WIN32)
        IF(CMAKE_MAJOR_VERSION EQUAL 2 AND CMAKE_MINOR_VERSION LESS 6)
            # Starting with 2.6.0 rely on CMAKE_RUNTIME_OUTPUT_DIRECTORY
            MPV_COPY_DLL_OUTPUT_TO_BINARY_DIR(${target})
        ENDIF()
    ENDIF(WIN32)

    # MPV treats Windows "plugins" as LIBRARY and not RUNTIME
    # installable targets
    IF(WIN32)
        INSTALL(TARGETS ${target}
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION bin
            ARCHIVE DESTINATION lib)
    ELSE()
        INSTALL(TARGETS ${target}
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib)
    ENDIF()

ENDMACRO(MPV_PLUGIN_PROCESS_TARGET target)

#
# This macro looks up the output file of a given target
# (a DLL for example) and copies it from where it is
# generated into the build specific directory in
# EXECUTABLE_OUTPUT_PATH.  For example, Debug/foo.dll
# would be copied to bin/Debug/foo.dll.
#
MACRO(MPV_COPY_TARGET_OUTPUT_TO_BINARY_DIR _target)
    GET_TARGET_PROPERTY(_file ${_target} LOCATION)
    ADD_CUSTOM_COMMAND(TARGET ${_target} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/)
    ADD_CUSTOM_COMMAND(TARGET ${_target} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${_file} ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/)
ENDMACRO(MPV_COPY_TARGET_OUTPUT_TO_BINARY_DIR)

#
# This macro copies DLL files generated by targets on WIN32
# to the binary directory (bin/Debug, bin/Release, etc.)
# On non WIN32 platforms it does nothing
#
MACRO(MPV_COPY_DLL_OUTPUT_TO_BINARY_DIR _target)
    IF(WIN32)
        GET_TARGET_PROPERTY(_type ${_target} TYPE)
        IF(_type STREQUAL "SHARED_LIBRARY" OR _type STREQUAL "MODULE_LIBRARY")
            MPV_COPY_TARGET_OUTPUT_TO_BINARY_DIR(${_target})
        ELSE(_type STREQUAL "SHARED_LIBRARY" OR _type STREQUAL "MODULE_LIBRARY")
            MESSAGE(FATAL_ERROR "Target ${_target} does not generate DLLs!")
        ENDIF(_type STREQUAL "SHARED_LIBRARY" OR _type STREQUAL "MODULE_LIBRARY")
    ENDIF(WIN32)
ENDMACRO(MPV_COPY_DLL_OUTPUT_TO_BINARY_DIR)

#
# A wrapper for TARGET_LINK_LIBRARIES() which lets the MPV link against
# MSVC debug libraries of the OSG when applicable and also warn users
# when they are missing.
#
MACRO(MPV_TARGET_LINK_OSG_LIBRARIES _target)
    IF(MSVC)
        FOREACH(_lib ${ARGN})
            IF(EXISTS ${_lib})
                # do a simple string replacement to obtain the debugged libname
                STRING(REPLACE ".lib" "d.lib" _libd ${_lib})
                IF(NOT EXISTS ${_libd})
                    SET(_MPV_warn_msvc_user true)
                ELSE()
                    TARGET_LINK_LIBRARIES(${_target} debug ${_libd})
                ENDIF()
            ENDIF()
            TARGET_LINK_LIBRARIES(${_target} optimized ${_lib})
        ENDFOREACH()

        IF(_MPV_warn_msvc_user AND NOT _MPV_have_warned_msvc_user)
            MESSAGE("WARNING: You do not have debug libraries of the OSG built
            (osgd.lib, etc.)!  Until you provide these debug libraries you
            will not be able to build a Debug build of the MPV.  Click OK to
            acknowledge this.")
            SET(_MPV_have_warned_msvc_user true CACHE INTERNAL "")
        ENDIF()
    ELSE()
        TARGET_LINK_LIBRARIES(${_target} ${ARGN})
    ENDIF()
ENDMACRO()

#
# A wrapper for TARGET_LINK_LIBRARIES() which lets the MPV link against
# either a debug/release version of the CCL when on MSVC.
#
MACRO(MPV_TARGET_LINK_CCL_LIBRARIES _target)
    IF(MSVC)
        TARGET_LINK_LIBRARIES(${_target}
            optimized ${CCL_LIBRARY}
            debug     ${CCL_LIBRARY_DEBUG})
    ELSE()
        TARGET_LINK_LIBRARIES(${_target} ${CCL_LIBRARY})
    ENDIF()
ENDMACRO()
